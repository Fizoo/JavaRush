Shortener (1)

ƒавай напишем укорачиватель Shortener. Ёто будет некий аналог укорачивател€

ссылок Google URL Shortener (https://goo.gl), но мы расширим его функциональность и

сделаем консольным. ќн будет сокращать не только ссылки, но и любые строки.

Ќаш Shortener - это класс, который может дл€ любой строки вернуть некий

уникальный идентификатор и наоборот, по ранее полученному идентификатору

вернуть строку.



ƒва дополнительных требовани€ к Shortener:

- дл€ двух одинаковых строк должен возвращатьс€ один и тот же идентификатор;

- он должен поддерживать столько строк, сколько значений может принимать long,

именно этот тип будет использоватьс€ дл€ идентификатора.

ѕервое требование очень сильно вли€ет на производительность, т.к. при получении

идентификатора дл€ новой строки мы должны проверить не обрабатывалась ли эта

строка ранее, чтобы вернуть старый идентификатор.



1.1. ќбъ€ви класс Shortener.

1.2. ƒобавь методы заглушки в объ€вленный класс:

1.2.1. Long getId(String string) - будет возвращать идентификатор id дл€ заданной

строки.

1.2.2. String getString(Long id) - будет возвращать строку дл€ заданного

идентификатора или null, если передан неверный идентификатор.



1.3. —оздай класс Solution с пустым методом main.



P.S. ¬се методы делай публичными, а пол€ приватными, если нет €вных указаний касательно модификаторов доступа.





“ребовани€:

1.?¬ классе Shortener должен быть объ€влен метод public Long getId(String string).

2.?¬ классе Shortener должен быть объ€влен метод public Long String getString(Long id).

3.?¬ классе Solution должен быть объ€влен метод public static void main(String[] args).

Shortener (2)

”корачиватель Shortener будет поддерживать разные стратегии хранени€ данных (строк и их идентификаторов). ¬се эти стратегии будут наследоватьс€ от интерфейса StorageStrategy. ѕочитай подробнее про паттерн —тратеги€ на ¬ики.

Ќаше хранилище будет оперировать двум€ пон€ти€ми: ключ и значение.  лючом будет идентификатор строки, а значением сама строка.



2.1. ƒобавь интерфейс StorageStrategy в пакет strategy.

2.2. ƒобавь в интерфейс следующие методы:

2.2.1. boolean containsKey(Long key) - должен вернуть true, если хранилище

содержит переданный ключ.

2.2.2. boolean containsValue(String value) - должен вернуть true, если хранилище

содержит переданное значение.

2.2.3. void put(Long key, String value) - добавить в хранилище новую пару ключ -

значение.

2.2.4. Long getKey(String value) - вернуть ключ дл€ переданного значени€.

2.2.5. String getValue(Long key) - вернуть значение дл€ переданного ключа.





“ребовани€:

1.?¬ интерфейсе StorageStrategy должен быть объ€влен метод boolean containsKey(Long key).

2.?¬ интерфейсе StorageStrategy должен быть объ€влен метод boolean containsValue(String value).

3.?¬ интерфейсе StorageStrategy должен быть объ€влен метод void put(Long key, String value).

4.?¬ интерфейсе StorageStrategy должен быть объ€влен метод Long getKey(String value).

5.?¬ интерфейсе StorageStrategy должен быть объ€влен метод boolean String getValue(Long key).

6.?»нтерфейс StorageStrategy должен быть создан в пакете strategy.

Shortener (3)

¬ернемс€ к классу Shortener:

3.1. ƒобавь в него поле Long lastId. ѕроинициализируй его нулем. Ёто поле будет

отвечать за последнее значение идентификатора, которое было использовано при добавлении новой строки в хранилище.

3.2. ƒобавь поле StorageStrategy storageStrategy в котором будет хранитьс€ стратеги€ хранени€ данных.

3.3. ƒобавь конструктор, который принимает StorageStrategy и инициализирует соответствующее поле класса.

3.4. –еализуй метод getId, он должен:

3.4.1. ѕроверить есть ли переданное значение в хранилище, если есть - вернуть его ключ.

3.4.2. ≈сли преданного значени€ нет в хранилище, то:

3.4.2.1. ”величить значение lastId на единицу;

3.4.2.2. ƒобавить в хранилище новую пару ключ-значение (новое значение lastId и переданную строку);

3.4.2.3. ¬ернуть новое значение lastId.

3.5. –еализуй метод getString, он должен вернуть строку по заданному идентификатору (ключу).

3.6. ѕредусмотреть возможность вызова методов getId и getString из разных потоков добавив соответствующий модификатор к заголовкам методов.





“ребовани€:

1.?¬ классе Shortener должно быть создано приватное поле Long lastId инициализированное нулем.

2.?¬ классе Shortener должно быть создано приватное поле storageStrategy типа StorageStrategy.

3.? онструктор класса Shortener должен принимать один параметр типа StorageStrategy и инициализировать им поле storageStrategy.

4.?ћетод getId должен быть реализован в соответствии с условием задачи.

5.?ћетод getString должен быть реализован в соответствии с условием задачи.

Shortener (4)

Ќам потребуетс€ несколько вспомогательных классов:

4.1. —оздай класс Helper.

4.1.1. ƒобавь в него статический метод String generateRandomString(), который будет генерировать случайную строку. ¬оспользуйс€ дл€ этого классами SecureRandom и BigInteger. ѕодсказка: гугли запрос "random string java". —трока может состо€ть из цифр и любой из 26 маленьких букв английского алфавита.

4.1.2. ƒобавь в класс статический метод printMessage(String message). ќн должен выводить переданный текст в консоль. ¬есь дальнейший вывод в программе должен быть реализован через этот метод!

4.2. —оздай класс ExceptionHandler.

4.2.1. ƒобавь в него статический метод log(Exception e), который будет выводить краткое описание исключени€.





“ребовани€:

1.?ћетод generateRandomString класса Helper должен генерировать случайную строку использу€ способ описанный в условии задачи.

2.?ћетод printMessage класса Helper должен выводить переданный текст на экран.

3.?ћетод log класса ExceptionHandler должен выводить на экран краткое описание исключени€.

Shortener (5)

ƒавай напишем наше первое хранилище (стратегию хранилища). ¬нутри оно будет содержать обычный HashMap. ¬се стратегии будем хранить в пакете strategy.

5.1. —оздай класс HashMapStorageStrategy, реализующий интерфейс StorageStrategy.

5.2. ƒобавь в класс поле HashMap<Long, String> data. ¬ нем будут хранитьс€ наши данные.

5.3. –еализуй в классе все необходимые методы. –еализации методов должны использовать поле data. ƒополнительные пол€ не создавать.





“ребовани€:

1.? ласс HashMapStorageStrategy должен поддерживать интерфейс StorageStrategy.

2.?¬ классе HashMapStorageStrategy должно быть создано и инициализировано поле data типа HashMap.

3.?¬ классе HashMapStorageStrategy должен быть корректно реализован метод containsKey.

4.?¬ классе HashMapStorageStrategy должен быть корректно реализован метод containsValue.

5.?¬ классе HashMapStorageStrategy должен быть корректно реализован метод put.

6.?¬ классе HashMapStorageStrategy должен быть корректно реализован метод getValue.

7.?¬ классе HashMapStorageStrategy должен быть корректно реализован метод getKey.

Shortener (6)

ѕерва€ стратеги€ готова, пришло врем€ ее протестить. ƒл€ этого:

6.1. —оздай класс Solution, если ты не сделал это раньше.

6.2. ƒобавь в класс Solution реализации вспомогательных статических методов:

6.2.1. Set<Long> getIds(Shortener shortener, Set<String> strings). Ётот метод должен дл€ переданного множества строк возвращать множество идентификаторов. »дентификатор дл€ каждой отдельной строки нужно получить, использу€ shortener.

6.2.2. Set<String> getStrings(Shortener shortener, Set<Long> keys). ћетод будет возвращать множество строк, которое соответствует переданному множеству идентификаторов.

ѕри реальном использовании Shortener, задача получить из множества строк множество идентификаторов и наоборот скорее всего не встретитс€, это нужно исключительно дл€ тестировани€.

6.2.3. testStrategy(StorageStrategy strategy, long elementsNumber). ћетод будет тестировать работу переданной стратегии на определенном количестве элементов elementsNumber. –еализаци€ метода должна:

6.2.3.1. ¬ыводить им€ класса стратегии. »м€ не должно включать им€ пакета.

6.2.3.2. √енерировать тестовое множество строк, использу€ Helper и заданное количество элементов elementsNumber.

6.2.3.3. —оздавать объект типа Shortener, использу€ переданную стратегию.

6.2.3.4. «амер€ть и выводить врем€ необходимое дл€ отработки метода getIds дл€ заданной стратегии и заданного множества элементов. ¬рем€ вывести в миллисекундах. ѕри замере времени работы метода можно пренебречь переключением процессора на другие потоки, временем, которое тратитс€ на сам вызов, возврат значений и вызов методов получени€ времени (даты). «амер времени произведи с использованием объектов типа Date.

6.2.3.5. «амер€ть и выводить врем€ необходимое дл€ отработки метода getStrings дл€ заданной стратегии и полученного в предыдущем пункте множества идентификаторов.

6.2.3.6. —равнивать одинаковое ли содержимое множества строк, которое было сгенерировано и множества, которое было возвращено методом getStrings. ≈сли множества одинаковы, то выведи "“ест пройден.", иначе "“ест не пройден.".

6.2.4. ƒобавь метод main(). ¬нутри метода протестируй стратегию HashMapStorageStrategy с помощью 10000 элементов.

6.3. ѕроверь, что программа работает и тест пройден.





“ребовани€:

1.?ћетод getIds должен дл€ переданного множества строк возвращать множество идентификаторов.

2.?ћетод getStrings должен дл€ переданного множества идентификаторов возвращать множество строк.

3.?ћетод testStrategy должен выводить на экран им€ класса стратегии.

4.?ћетод testStrategy должен генерировать тестовое множество строк использу€ метод generateRandomString класса Helper (количество элементов должно быть равно параметру elementsNumber).

5.?ћетод testStrategy должен создавать объект типа Shortener использу€ переданную стратегию.

6.?ћетод testStrategy должен замер€ть количество времени выполнени€ методов getIds и getStrings использу€ объекты типа Date.

7.?ћетод testStrategy должен сравнивать количество сгенерированных строк и строк в множестве полученном в результате работы метода getStrings и выводить на экран результат прохождени€ теста.

8.?¬ методе main должен быть вызван метод testStrategy.

Shortener (7)

ѕриступим к реализации второй стратегии OurHashMapStorageStrategy. ќна не будет использовать готовый HashMap из стандартной библиотеки, а будет сама €вл€тьс€ коллекцией.



7.1. –азберись как работает стандартный HashMap, посмотри его исходники или погугли статьи на эту тему.

7.2. ≈сли ты честно выполнил предыдущий пункт, то ты знаешь дл€ чего используетс€ класс Node поддерживающий интерфейс Entry внутри HashMap. —оздай свой аналог внутри пакета strategy. Ёто должен быть обычный, не вложенный, не generic класс. —делай его публичным.

¬ отличии от класса Node из HashMap, наш класс будет поддерживать только интерфейс Serializable и будет называтьс€ Entry.

7.3. ƒобавь в Entry следующие пол€: Long key, String value, Entry next, int hash.  ак видишь, наша реализаци€ будет поддерживать только тип Long дл€ ключа и только String дл€ значени€. ќбласть видимости полей оставь по умолчанию.

7.4. ƒобавь и реализуй конструктор Entry(int hash, Long key, String value, Entry next).

7.5. ƒобавь и реализуй методы: Long getKey(), String getValue(), int hashCode(), boolean equals() и String toString(). –еализовывать остальные методы оригинального Entry не нужно, мы пишем упрощенную версию.





“ребовани€:

1.?¬ классе Entry должны быть созданы пол€ перечисленные в условии задачи.

2.?¬ классе Entry должен быть реализован конструктор с четырьм€ параметрами (int, Long, String, Entry) инициализирующий соответствующие пол€ класса.

3.?ћетод getKey должен возвращать значение пол€ key.

4.?ћетод getValue должен возвращать значение пол€ value.

5.?ћетод toString должен возвращать строку формата key + "=" + value.

6.?ћетоды hashCode и equals должны быть корректно реализованы использу€ дл€ сравнени€ пол€ key и value.

Shortener (8)
Добавь и реализуй класс OurHashMapStorageStrategy, используя класс Entry из предыдущей подзадачи. Класс OurHashMapStorageStrategy должен реализовывать интерфейс StorageStrategy.
8.1. Добавь в класс следующие поля:
8.1.1. static final int DEFAULT_INITIAL_CAPACITY = 16;
8.1.2. static final float DEFAULT_LOAD_FACTOR = 0.75f;
8.1.3. Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY];
8.1.4. int size;
8.1.5. int threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
8.1.6. float loadFactor = DEFAULT_LOAD_FACTOR;
8.2. Реализуй в классе следующие вспомогательные методы:
8.2.1. int hash(Long k)
8.2.2. int indexFor(int hash, int length)
8.2.3. Entry getEntry(Long key)
8.2.4. void resize(int newCapacity)
8.2.5. void transfer(Entry[] newTable)
8.2.6. void addEntry(int hash, Long key, String value, int bucketIndex)
8.2.7. void createEntry(int hash, Long key, String value, int bucketIndex)
8.3. Добавь в класс публичные методы, которые требует интерфейс StorageStrategy.
Какие-либо дополнительные поля класса не использовать. Методы, не описанные в задании, реализовывать не нужно. Если возникнут вопросы как реализовать какой-то метод или что он должен делать, то ты всегда можешь посмотреть, как работает похожий метод в HashMap.
Можешь добавить в метод main класса Solution тестирование новой стратегии. Запусти и сравни время работы двух стратегий на одинаковом количестве элементов.


Требования:
1. Класс OurHashMapStorageStrategy должен поддерживать интерфейс StorageStrategy.
2. В классе OurHashMapStorageStrategy должны быть созданы все необходимые поля (согласно условию задачи).
3. Методы интерфейса StorageStrategy должны быть реализованы в OurHashMapStorageStrategy таким образом, чтобы обеспечивать корректную работу Shortener созданного на его основе.
4. В классе OurHashMapStorageStrategy должны присутствовать все вспомогательные методы перечисленные в условии задачи.

Shortener (9)
Напишем еще одну стратегию, назовем ее FileStorageStrategy. Она будет очень похожа на стратегию OurHashMapStorageStrategy, но в качестве ведер (англ. buckets) будут файлы. Я знаю, ты знаешь о каких buckets идет речь, если нет - повтори внутреннее устройство HashMap.
9.1. Создай класс FileBucket в пакете strategy.
9.2. Добавь в класс поле Path path. Это будет путь к файлу.
9.3. Добавь в класс конструктор без параметров, он должен:
9.3.1. Инициализировать path временным файлом. Файл должен быть размещен в директории для временных файлов и иметь случайное имя.

Подсказка: Files.createTempFile.

9.3.2. Создавать новый файл, используя path. Если такой файл уже есть, то заменять его.
9.3.3. Обеспечивать удаление файла при выходе из программы.

Подсказка: deleteOnExit().

9.4. Добавь в класс методы:
9.4.1. long getFileSize(), он должен возвращать размер файла на который указывает path.
9.4.2. void putEntry(Entry entry) - должен сериализовывать переданный entry в файл. Учти, каждый entry может содержать еще один entry.
9.4.3. Entry getEntry() - должен забирать entry из файла. Если файл имеет нулевой размер, вернуть null.
9.4.4. void remove() - удалять файл на который указывает path.
Конструктор и методы не должны кидать исключения.


Требования:
1. В классе FileBucket должно быть создано поле path типа Path.
2. Конструктор без параметров класса FileBucket должен быть реализован в соответствии с условием задачи.
3. Метод getFileSize должен возвращать размер файла на который указывает path.
4. Метод putEntry должен сериализовывать полученный объект типа Entry в файл на который указывает path, чтобы получить OutputStream используй метод Files.newOutputStream.
5. Метод getEntry должен десериализовывать объект типа Entry из файл на который указывает path, чтобы получить InputStream используй метод Files.newInputStream.
6. Метод remove должен удалять файл на который указывает path с помощью метода Files.delete().
